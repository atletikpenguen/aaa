"""
DCA + OTT Strategy Implementation
Kullanƒ±cƒ±nƒ±n tarif ettiƒüi strateji mantƒ±ƒüƒ±
"""

import os
from typing import Dict, Any, List
from datetime import datetime, timezone

from .base_strategy import BaseStrategy
from .models import (
    Strategy, State, TradingSignal, OrderSide, OTTMode, OTTResult, 
    MarketInfo, Trade, DCAPosition
)
from .utils import (
    logger, round_to_tick, calculate_quantity
)


class DCAOTTStrategy(BaseStrategy):
    """
    DCA + OTT strateji implementasyonu
    
    ALIM KURALLARI:
    1. OTT AL verdiƒüinde alƒ±m yapƒ±lƒ±r (SAT verdiƒüinde SHORT yok)
    2. ƒ∞lk alƒ±m: base_usdt kadar USDT ile alƒ±m
    3. DCA alƒ±mlarƒ±: Fiyat ilk alƒ±m fiyatƒ±nƒ±n altƒ±nda VE ortalama maliyetten min_drop_pct kadar d√º≈ü√ºkse
    4. DCA miktarƒ±: base_usdt √ó (dca_multiplier ^ pozisyon_sayƒ±sƒ±)
    
    SATI≈û KURALLARI:
    1. Kƒ±smi satƒ±≈ü: OTT SAT verdiƒüinde, fiyat son alƒ±m fiyatƒ±nƒ±n %1 √ºzerindeyse ‚Üí sadece son pozisyonu sat
    2. Tam satƒ±≈ü: OTT SAT verdiƒüinde, fiyat ortalama maliyetin %1 √ºzerindeyse ‚Üí t√ºm pozisyonu sat
    3. Tam satƒ±≈ü sonrasƒ±: Yeni d√∂ng√º ba≈ülar (state sƒ±fƒ±rlanƒ±r)
    """
    
    def __init__(self):
        super().__init__("DCA+OTT")
        # Environment'dan debug modunu al
        self.debug_enabled = os.getenv('DCA_DEBUG_ENABLED', 'false').lower() == 'true'
    
    def _debug_log(self, strategy_id: str, message: str, level: str = "INFO"):
        """DCA+OTT √∂zel debug log"""
        if self.debug_enabled:
            timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
            log_message = f"[DCA+OTT DEBUG] {strategy_id} | {timestamp} | {message}"
            
            if level == "ERROR":
                logger.error(log_message)
            elif level == "WARNING":
                logger.warning(log_message)
            elif level == "DEBUG":
                logger.debug(log_message)
            else:
                logger.info(log_message)
    
    def _debug_open_orders_check(self, strategy_id: str, state: State) -> bool:
        """A√ßƒ±k emir kontrol√º ve debug log"""
        open_orders_count = len(state.open_orders)
        
        self._debug_log(strategy_id, f"üîç A√ßƒ±k emir kontrol√º: {open_orders_count} emir")
        
        if open_orders_count > 0:
            for i, order in enumerate(state.open_orders):
                age_minutes = (datetime.now(timezone.utc) - order.timestamp).total_seconds() / 60
                self._debug_log(strategy_id, f"  üìã Emir {i+1}: {order.side.value} {order.quantity} @ {order.price} (Ya≈ü: {age_minutes:.1f}dk)")
            
            self._debug_log(strategy_id, f"‚ùå Yeni emir engellendi: {open_orders_count} a√ßƒ±k emir var", "WARNING")
            return True  # A√ßƒ±k emir var
        
        self._debug_log(strategy_id, "‚úÖ A√ßƒ±k emir yok - yeni emir g√∂nderilebilir")
        return False  # A√ßƒ±k emir yok
    
    def _debug_position_analysis(self, strategy_id: str, position_analysis: Dict[str, Any]):
        """Pozisyon analizi debug log"""
        self._debug_log(strategy_id, "üìä Pozisyon Analizi:")
        self._debug_log(strategy_id, f"  üí∞ Pozisyon var: {position_analysis['has_positions']}")
        self._debug_log(strategy_id, f"  üìà Toplam miktar: {position_analysis['total_quantity']}")
        self._debug_log(strategy_id, f"  üíµ Ortalama maliyet: ${position_analysis['avg_cost']:.4f}")
        self._debug_log(strategy_id, f"  üéØ ƒ∞lk alƒ±m fiyatƒ±: ${position_analysis['first_buy_price']:.4f}")
        self._debug_log(strategy_id, f"  üìâ Son alƒ±m fiyatƒ±: ${position_analysis['last_buy_price']:.4f}")
        self._debug_log(strategy_id, f"  üíö Kar/Zarar: ${position_analysis['unrealized_pnl']:.2f} ({position_analysis['unrealized_pnl_pct']:.2f}%)")
        self._debug_log(strategy_id, f"  ‚úÖ Karlƒ±: {position_analysis['is_profitable']}")
    
    def _debug_ott_analysis(self, strategy_id: str, ott_result: OTTResult, current_price: float):
        """OTT analizi debug log"""
        self._debug_log(strategy_id, "üéØ OTT Analizi:")
        self._debug_log(strategy_id, f"  üîÑ OTT Modu: {ott_result.mode.value}")
        self._debug_log(strategy_id, f"  üìä Baseline: ${ott_result.baseline:.4f}")
        self._debug_log(strategy_id, f"  üí∞ G√ºncel Fiyat: ${current_price:.4f}")
        
        if ott_result.mode == OTTMode.AL:
            price_diff = current_price - ott_result.baseline
            self._debug_log(strategy_id, f"  üìà Fiyat farkƒ±: ${price_diff:.4f} (AL modu)")
        else:
            price_diff = ott_result.baseline - current_price
            self._debug_log(strategy_id, f"  üìâ Fiyat farkƒ±: ${price_diff:.4f} (SAT modu)")
    
    def _debug_dca_parameters(self, strategy_id: str, base_usdt: float, dca_multiplier: float, min_drop_pct: float, use_market_orders: bool):
        """DCA parametreleri debug log"""
        self._debug_log(strategy_id, "‚öôÔ∏è DCA Parametreleri:")
        self._debug_log(strategy_id, f"  üíµ ƒ∞lk alƒ±m tutarƒ±: ${base_usdt}")
        self._debug_log(strategy_id, f"  üìà DCA √ßarpanƒ±: {dca_multiplier}x")
        self._debug_log(strategy_id, f"  üìâ Min d√º≈ü√º≈ü %: {min_drop_pct}%")
        self._debug_log(strategy_id, f"  üöÄ Market emir: {'‚úÖ Aktif' if use_market_orders else '‚ùå Limit emir'}")
    
    def _debug_signal_decision(self, strategy_id: str, signal: TradingSignal, reason: str = ""):
        """Sinyal kararƒ± debug log"""
        if signal.should_trade:
            price_info = f" @ ${signal.target_price}" if signal.target_price else " (Market)"
            self._debug_log(strategy_id, f"‚úÖ Sƒ∞NYAL ONAYLANDI: {signal.side.value} {signal.quantity}{price_info}")
            self._debug_log(strategy_id, f"  üìù Sebep: {signal.reason}")
            if signal.strategy_specific_data:
                self._debug_log(strategy_id, f"  üîß √ñzel veri: {signal.strategy_specific_data}")
        else:
            self._debug_log(strategy_id, f"‚ùå Sƒ∞NYAL ENGELLENDƒ∞: {signal.reason}")
            if reason:
                self._debug_log(strategy_id, f"  üìù Ek sebep: {reason}")
    
    async def initialize_state(self, strategy: Strategy) -> Dict[str, Any]:
        """DCA+OTT i√ßin initial state"""
        self._debug_log(strategy.id, "üöÄ DCA+OTT strateji ba≈ülatƒ±lƒ±yor")
        return {
            "first_buy_executed": False,
            "last_ott_action": None,
            "profit_threshold": 0.0,  # Karlƒ±lƒ±k e≈üiƒüi (%)
            "use_market_orders": True  # Market emir kullanƒ±mƒ± (varsayƒ±lan: True)
        }
    
    async def calculate_signal(
        self, 
        strategy: Strategy, 
        state: State, 
        current_price: float, 
        ott_result: OTTResult,
        market_info: MarketInfo,
        ohlcv_data: list = None
    ) -> TradingSignal:
        """DCA+OTT sinyal hesaplama"""
        
        self._debug_log(strategy.id, "=" * 60)
        self._debug_log(strategy.id, f"üîÑ DCA+OTT Sinyal Hesaplama Ba≈üladƒ± - Fiyat: ${current_price}")
        self._debug_log(strategy.id, "=" * 60)
        
        # 1Ô∏è‚É£ A√ßƒ±k emir kontrol√º - EN √ñNEMLƒ∞ KONTROL
        if self._debug_open_orders_check(strategy.id, state):
            return TradingSignal(
                should_trade=False,
                reason=f"A√ßƒ±k emir beklemede: {len(state.open_orders)} emir"
            )
        
        # 2Ô∏è‚É£ Fiyat limitleri kontrol√º
        price_valid, price_reason = self._check_price_limits(current_price, market_info)
        if not price_valid:
            self._debug_log(strategy.id, f"‚ùå Fiyat limitleri kontrol√º ba≈üarƒ±sƒ±z: {price_reason}", "WARNING")
            return TradingSignal(
                should_trade=False,
                reason=price_reason
            )
        self._debug_log(strategy.id, "‚úÖ Fiyat limitleri kontrol√º ge√ßti")
        
        # 3Ô∏è‚É£ DCA parametrelerini al
        base_usdt = self.get_parameter(strategy, 'base_usdt', 100.0)
        dca_multiplier = self.get_parameter(strategy, 'dca_multiplier', 1.5)
        min_drop_pct = self.get_parameter(strategy, 'min_drop_pct', 2.0)
        use_market_orders = state.custom_data.get('use_market_orders', True)
        self._debug_dca_parameters(strategy.id, base_usdt, dca_multiplier, min_drop_pct, use_market_orders)
        
        # 4Ô∏è‚É£ Mevcut pozisyon durumunu analiz et
        position_analysis = self._analyze_positions(state, current_price)
        self._debug_position_analysis(strategy.id, position_analysis)
        
        # 5Ô∏è‚É£ OTT analizi
        self._debug_ott_analysis(strategy.id, ott_result, current_price)
        
        # 6Ô∏è‚É£ OTT moduna g√∂re karar ver
        if ott_result.mode == OTTMode.AL:
            signal = await self._handle_ott_buy_signal(
                strategy, state, current_price, market_info, 
                position_analysis, base_usdt, dca_multiplier, min_drop_pct, use_market_orders
            )
        else:  # SAT
            signal = await self._handle_ott_sell_signal(
                strategy, state, current_price, market_info,
                position_analysis, use_market_orders
            )
        
        # 7Ô∏è‚É£ Final sinyal kararƒ±
        self._debug_signal_decision(strategy.id, signal)
        
        self._debug_log(strategy.id, "=" * 60)
        self._debug_log(strategy.id, "üèÅ DCA+OTT Sinyal Hesaplama Tamamlandƒ±")
        self._debug_log(strategy.id, "=" * 60)
        
        return signal
    
    def _check_price_limits(self, current_price: float, market_info: MarketInfo) -> tuple[bool, str]:
        """Fiyat limitleri kontrol√º"""
        # Minimum fiyat kontrol√º
        if current_price <= 0:
            return False, "Fiyat sƒ±fƒ±r veya negatif"
        
        # Maksimum fiyat kontrol√º (√ßok y√ºksek fiyatlarƒ± engelle)
        if current_price > 1000000:  # 1M USDT √ºzeri
            return False, "Fiyat √ßok y√ºksek"
        
        return True, "Fiyat limitleri ge√ßerli"
    
    def _analyze_positions(self, state: State, current_price: float) -> Dict[str, Any]:
        """Mevcut pozisyon durumunu analiz et"""
        
        if not state.dca_positions:
            return {
                "has_positions": False,
                "total_quantity": 0.0,
                "avg_cost": 0.0,
                "first_buy_price": 0.0,
                "last_buy_price": 0.0,
                "unrealized_pnl": 0.0,
                "unrealized_pnl_pct": 0.0,
                "is_profitable": False,
                "position_count": 0
            }
        
        # Toplam miktar ve ortalama maliyet hesapla
        total_quantity = sum(pos.quantity for pos in state.dca_positions)
        total_cost = sum(pos.buy_price * pos.quantity for pos in state.dca_positions)
        avg_cost = total_cost / total_quantity if total_quantity > 0 else 0
        
        # ƒ∞lk ve son alƒ±m fiyatlarƒ±
        sorted_positions = sorted(state.dca_positions, key=lambda x: x.timestamp)
        first_buy_price = sorted_positions[0].buy_price
        last_buy_price = sorted_positions[-1].buy_price
        
        # Ger√ßekle≈ümemi≈ü kar/zarar
        current_value = total_quantity * current_price
        total_invested = total_cost
        unrealized_pnl = current_value - total_invested
        unrealized_pnl_pct = (unrealized_pnl / total_invested * 100) if total_invested > 0 else 0
        
        return {
            "has_positions": True,
            "total_quantity": total_quantity,
            "avg_cost": avg_cost,
            "first_buy_price": first_buy_price,
            "last_buy_price": last_buy_price,
            "unrealized_pnl": unrealized_pnl,
            "unrealized_pnl_pct": unrealized_pnl_pct,
            "is_profitable": unrealized_pnl > 0,
            "position_count": len(state.dca_positions)
        }
    
    async def _handle_ott_buy_signal(
        self,
        strategy: Strategy,
        state: State,
        current_price: float,
        market_info: MarketInfo,
        position_analysis: Dict[str, Any],
        base_usdt: float,
        dca_multiplier: float,
        min_drop_pct: float,
        use_market_orders: bool = True
    ) -> TradingSignal:
        """OTT AL sinyali i≈üleme"""
        
        self._debug_log(strategy.id, f"üîç DCA+OTT {strategy.id}: OTT AL sinyali analizi - Fiyat: ${current_price}")
        self._debug_log(strategy.id, f"   Pozisyon durumu: {position_analysis}")
        self._debug_log(strategy.id, f"   Parametreler: base_usdt=${base_usdt}, dca_multiplier={dca_multiplier}, min_drop_pct={min_drop_pct}%")
        
        # Kural 1: ƒ∞lk alƒ±m (hen√ºz pozisyon yok)
        if not position_analysis["has_positions"]:
            self._debug_log(strategy.id, f"   üìà ƒ∞lk alƒ±m sinyali - Hen√ºz pozisyon yok (D√∂ng√º: D{state.cycle_number})")
            
            # Minimum USDT tutarƒ±nƒ± kontrol et
            min_notional = market_info.min_notional
            if base_usdt < min_notional:
                self._debug_log(strategy.id, f"   ‚ùå ƒ∞lk alƒ±m engellendi: USDT tutarƒ± √ßok d√º≈ü√ºk (${base_usdt} < ${min_notional})", "WARNING")
                return TradingSignal(
                    should_trade=False,
                    reason=f"ƒ∞lk alƒ±m: USDT tutarƒ± √ßok d√º≈ü√ºk (${base_usdt} < ${min_notional})"
                )
            
            quantity, is_valid = calculate_quantity(
                base_usdt, current_price, market_info.step_size, market_info.min_qty
            )
            
            if not is_valid:
                self._debug_log(strategy.id, f"   ‚ùå ƒ∞lk alƒ±m engellendi: Miktar ge√ßersiz ({quantity} < {market_info.min_qty})", "WARNING")
                return TradingSignal(
                    should_trade=False,
                    reason=f"ƒ∞lk alƒ±m: miktar ge√ßersiz ({quantity} < {market_info.min_qty})"
                )
            
            order_type = "MARKET" if use_market_orders else "LIMIT"
            target_price = None if use_market_orders else round_to_tick(current_price, market_info.tick_size)
            
            # ƒ∞lk alƒ±m i√ßin i≈ülem sayacƒ±nƒ± 1 olarak ayarla
            trade_count = state.cycle_trade_count + 1
            
            self._debug_log(strategy.id, f"   ‚úÖ ƒ∞lk alƒ±m sinyali onaylandƒ±: {quantity} @ ${current_price} ({order_type}) - D{state.cycle_number}-{trade_count}")
            return TradingSignal(
                should_trade=True,
                side=OrderSide.BUY,
                target_price=target_price,
                quantity=quantity,
                reason=f"ƒ∞lk alƒ±m: OTT AL sinyali ({order_type}) - D{state.cycle_number}-{trade_count}",
                strategy_specific_data={
                    "dca_type": "first_buy",
                    "usdt_amount": base_usdt,
                    "order_type": order_type,
                    "cycle_number": state.cycle_number,
                    "cycle_trade_count": trade_count
                }
            )
        
        # Kural 4: Fiyat ilk maliyetin √ºst√ºnde ‚Üí alƒ±m yok
        if current_price >= position_analysis["first_buy_price"]:
            self._debug_log(strategy.id, f"   ‚ùå AL engellendi: Fiyat (${current_price}) ilk alƒ±m fiyatƒ±nƒ±n (${position_analysis['first_buy_price']}) √ºst√ºnde", "WARNING")
            return TradingSignal(
                should_trade=False,
                reason=f"AL engellendi: Fiyat ({current_price}) ilk alƒ±m fiyatƒ±nƒ±n ({position_analysis['first_buy_price']}) √ºst√ºnde"
            )
        
        # üõ°Ô∏è EK G√úVENLIK: Fiyat son alƒ±m fiyatƒ±nƒ±n √ºst√ºnde ‚Üí alƒ±m yok (yanlƒ±≈ü DCA engelle)
        if current_price > position_analysis["last_buy_price"]:
            self._debug_log(strategy.id, f"   üö® AL engellendi: Fiyat (${current_price}) son alƒ±m fiyatƒ±nƒ±n (${position_analysis['last_buy_price']}) √ºst√ºnde - YANLI≈û DCA!", "WARNING")
            return TradingSignal(
                should_trade=False,
                reason=f"AL engellendi: Fiyat ({current_price}) son alƒ±m fiyatƒ±nƒ±n ({position_analysis['last_buy_price']}) √ºst√ºnde - DCA kuralƒ± ihlali"
            )
        
        # Kural 5: Fiyat yeterince d√º≈ümedi mi? (Son alƒ±m fiyatƒ±ndan d√º≈ü√º≈ü)
        drop_from_last = ((position_analysis["last_buy_price"] - current_price) / position_analysis["last_buy_price"]) * 100
        self._debug_log(strategy.id, f"   üìä D√º≈ü√º≈ü analizi: Son alƒ±m=${position_analysis['last_buy_price']}, D√º≈ü√º≈ü={drop_from_last:.2f}%, Min e≈üik={min_drop_pct}%")
        
        if drop_from_last < min_drop_pct:
            self._debug_log(strategy.id, f"   ‚ùå AL engellendi: D√º≈ü√º≈ü ({drop_from_last:.2f}%) minimum e≈üiƒüin ({min_drop_pct}%) altƒ±nda", "WARNING")
            return TradingSignal(
                should_trade=False,
                reason=f"AL engellendi: D√º≈ü√º≈ü ({drop_from_last:.2f}%) minimum e≈üiƒüin ({min_drop_pct}%) altƒ±nda"
            )
        
        # DCA alƒ±m miktarƒ±nƒ± hesapla
        position_count = position_analysis["position_count"]
        dca_usdt = base_usdt * (dca_multiplier ** position_count)
        
        self._debug_log(strategy.id, f"   üìä DCA hesaplama: Pozisyon sayƒ±sƒ±={position_count}, DCA USDT=${dca_usdt}")
        
        # Minimum USDT tutarƒ±nƒ± kontrol et
        min_notional = market_info.min_notional
        if dca_usdt < min_notional:
            self._debug_log(strategy.id, f"   ‚ùå DCA alƒ±m engellendi: USDT tutarƒ± √ßok d√º≈ü√ºk (${dca_usdt} < ${min_notional})", "WARNING")
            return TradingSignal(
                should_trade=False,
                reason=f"DCA alƒ±m: USDT tutarƒ± √ßok d√º≈ü√ºk (${dca_usdt} < ${min_notional})"
            )
        
        quantity, is_valid = calculate_quantity(
            dca_usdt, current_price, market_info.step_size, market_info.min_qty
        )
        
        if not is_valid:
            self._debug_log(strategy.id, f"   ‚ùå DCA alƒ±m engellendi: Miktar ge√ßersiz ({quantity} < {market_info.min_qty})", "WARNING")
            return TradingSignal(
                should_trade=False,
                reason=f"DCA alƒ±m: miktar ge√ßersiz ({quantity} < {market_info.min_qty})"
            )
        
        order_type = "MARKET" if use_market_orders else "LIMIT"
        target_price = None if use_market_orders else round_to_tick(current_price, market_info.tick_size)
        
        # DCA alƒ±m i√ßin i≈ülem sayacƒ±nƒ± artƒ±r
        trade_count = state.cycle_trade_count + 1
        
        self._debug_log(strategy.id, f"   ‚úÖ DCA alƒ±m sinyali onaylandƒ±: {quantity} @ ${current_price} ({position_count+1}. pozisyon, {order_type}) - D{state.cycle_number}-{trade_count}")
        return TradingSignal(
            should_trade=True,
            side=OrderSide.BUY,
            target_price=target_price,
            quantity=quantity,
            reason=f"DCA alƒ±m: {position_count+1}. pozisyon, {drop_from_last:.2f}% d√º≈ü√º≈ü ({order_type}) - D{state.cycle_number}-{trade_count}",
            strategy_specific_data={
                "dca_type": "dca_buy",
                "position_count": position_count + 1,
                "usdt_amount": dca_usdt,
                "drop_pct": drop_from_last,
                "order_type": order_type,
                "cycle_number": state.cycle_number,
                "cycle_trade_count": trade_count
            }
        )
    
    async def _handle_ott_sell_signal(
        self,
        strategy: Strategy,
        state: State,
        current_price: float,
        market_info: MarketInfo,
        position_analysis: Dict[str, Any],
        use_market_orders: bool = True
    ) -> TradingSignal:
        """OTT SAT sinyali i≈üleme - Yeni kurallar:
        1. Kƒ±smi satƒ±≈ü: Son alƒ±m fiyatƒ±nƒ±n %1 √ºzerinde
        2. Tam satƒ±≈ü: Ortalama maliyetin %1 √ºzerinde
        """
        
        self._debug_log(strategy.id, "üîç OTT SAT sinyali analizi ba≈üladƒ±")
        
        # Pozisyon yoksa satƒ±≈ü yapƒ±lamaz
        if not position_analysis["has_positions"]:
            self._debug_log(strategy.id, "‚ùå SAT engellendi: Pozisyon yok", "WARNING")
            return TradingSignal(
                should_trade=False,
                reason="SAT engellendi: Hi√ß pozisyon yok"
            )
        
        avg_cost = position_analysis["avg_cost"]
        last_buy_price = position_analysis["last_buy_price"]
        
        self._debug_log(strategy.id, f"üìä SAT Analizi: Ort. maliyet=${avg_cost:.4f}, Son alƒ±m=${last_buy_price:.4f}, G√ºncel fiyat=${current_price:.4f}")
        
        # Kural 1: Tam satƒ±≈ü - Ortalama maliyetin %1 √ºzerinde
        profit_threshold = avg_cost * 1.01  # %1 k√¢r e≈üiƒüi
        if current_price >= profit_threshold:
            total_quantity = position_analysis["total_quantity"]
            profit_pct = position_analysis["unrealized_pnl_pct"]
            order_type = "MARKET" if use_market_orders else "LIMIT"
            target_price = None if use_market_orders else round_to_tick(current_price, market_info.tick_size)
            
            self._debug_log(strategy.id, f"‚úÖ T√úM POZƒ∞SYON SATI≈ûI: Fiyat (${current_price}) >= K√¢r e≈üiƒüi (${profit_threshold:.4f}) - Kar: {profit_pct:.2f}% ({order_type}) - D{state.cycle_number} (TAMAMLANDI)")
            
            return TradingSignal(
                should_trade=True,
                side=OrderSide.SELL,
                target_price=target_price,
                quantity=round_to_tick(total_quantity, market_info.step_size),
                reason=f"T√ºm pozisyon satƒ±≈üƒ±: Fiyat ({current_price}) >= K√¢r e≈üiƒüi ({profit_threshold:.4f}) - %1 k√¢r ({order_type}) - D{state.cycle_number} (TAMAMLANDI)",
                strategy_specific_data={
                    "sell_type": "full_exit",
                    "profit_pct": position_analysis["unrealized_pnl_pct"],
                    "profit_threshold": profit_threshold,
                    "order_type": order_type,
                    "cycle_number": state.cycle_number,
                    "cycle_trade_count": 0  # Tam satƒ±≈üta sayacƒ± sƒ±fƒ±rla
                }
            )
        
        # Kural 2: Kƒ±smi satƒ±≈ü - Son alƒ±m fiyatƒ±nƒ±n %1 √ºzerinde
        partial_profit_threshold = last_buy_price * 1.01  # Son alƒ±mƒ±n %1 √ºzeri
        if current_price >= partial_profit_threshold:
            # Son alƒ±mƒ± bul
            sorted_positions = sorted(state.dca_positions, key=lambda x: x.timestamp, reverse=True)
            last_position = sorted_positions[0]
            order_type = "MARKET" if use_market_orders else "LIMIT"
            target_price = None if use_market_orders else round_to_tick(current_price, market_info.tick_size)
            
            profit_vs_last = ((current_price - last_buy_price) / last_buy_price) * 100
            
            # Kƒ±smi satƒ±≈ü i√ßin i≈ülem sayacƒ±nƒ± artƒ±r
            trade_count = state.cycle_trade_count + 1
            
            self._debug_log(strategy.id, f"‚úÖ KISMI SATI≈û: Fiyat (${current_price}) >= Son alƒ±m k√¢r e≈üiƒüi (${partial_profit_threshold:.4f}) - %{profit_vs_last:.2f} k√¢r ({order_type}) - D{state.cycle_number}-{trade_count}")
            
            return TradingSignal(
                should_trade=True,
                side=OrderSide.SELL,
                target_price=target_price,
                quantity=round_to_tick(last_position.quantity, market_info.step_size),
                reason=f"Son pozisyon satƒ±≈üƒ±: Fiyat ({current_price}) >= Son alƒ±m k√¢r e≈üiƒüi ({partial_profit_threshold:.4f}) - %{profit_vs_last:.2f} k√¢r ({order_type}) - D{state.cycle_number}-{trade_count}",
                strategy_specific_data={
                    "sell_type": "partial_exit",
                    "position_to_sell": last_position.order_id,
                    "profit_vs_last": profit_vs_last,
                    "partial_profit_threshold": partial_profit_threshold,
                    "order_type": order_type,
                    "cycle_number": state.cycle_number,
                    "cycle_trade_count": trade_count
                }
            )
        
        # Kural 3: Satƒ±≈ü ko≈üullarƒ± saƒülanmƒ±yor
        self._debug_log(strategy.id, f"‚ùå SAT engellendi: Fiyat (${current_price}) k√¢r e≈üiklerini kar≈üƒ±lamƒ±yor", "WARNING")
        self._debug_log(strategy.id, f"   üìä Gerekli e≈üikler: Tam satƒ±≈ü >= ${profit_threshold:.4f}, Kƒ±smi satƒ±≈ü >= ${partial_profit_threshold:.4f}")
        return TradingSignal(
            should_trade=False,
            reason=f"SAT engellendi: Fiyat ({current_price}) k√¢r e≈üiklerini kar≈üƒ±lamƒ±yor (Tam: {profit_threshold:.4f}, Kƒ±smi: {partial_profit_threshold:.4f})"
        )
    
    async def process_fill(
        self, 
        strategy: Strategy, 
        state: State, 
        trade: Trade
    ) -> Dict[str, Any]:
        """DCA+OTT fill i≈ülemi - pozisyon g√ºncelleme"""
        
        self._debug_log(strategy.id, f"üîÑ FILL ƒ∞≈ülemi: {trade.side.value} {trade.quantity} @ ${trade.price}")
        
        if trade.side == OrderSide.BUY:
            # ƒ∞lk alƒ±m ise d√∂ng√º sayƒ±sƒ±nƒ± artƒ±r ve i≈ülem sayacƒ±nƒ± sƒ±fƒ±rla
            if len(state.dca_positions) == 0:
                state.cycle_number += 1
                state.cycle_trade_count = 0
                self._debug_log(strategy.id, f"üîÑ YENƒ∞ D√ñNG√ú BA≈ûLADI: D{state.cycle_number}")
            
            # ƒ∞≈ülem sayacƒ±nƒ± artƒ±r
            state.cycle_trade_count += 1
            
            # üõ°Ô∏è G√úVENLIK KONTROL√ú: Aynƒ± order_id ile pozisyon var mƒ±?
            existing_position = None
            for pos in state.dca_positions:
                if pos.order_id == trade.order_id:
                    existing_position = pos
                    break
            
            if existing_position:
                self._debug_log(strategy.id, f"‚ö†Ô∏è DUPLICATE FILL: Order {trade.order_id} zaten pozisyonlarda var, atlanƒ±yor", "WARNING")
                return {
                    "action": "duplicate_fill_ignored",
                    "existing_position": existing_position.buy_price
                }
            
            # Yeni pozisyon ekle
            new_position = DCAPosition(
                buy_price=trade.price,
                quantity=trade.quantity,
                timestamp=trade.timestamp,
                order_id=trade.order_id
            )
            state.dca_positions.append(new_position)
            
            # üìä DETAYLI LOG: Pozisyon listesi
            self._debug_log(strategy.id, f"üìã Pozisyon listesi ({len(state.dca_positions)} adet):")
            for i, pos in enumerate(state.dca_positions, 1):
                self._debug_log(strategy.id, f"   {i}. {pos.quantity} @ ${pos.buy_price} (Order: {pos.order_id})")
            
            # Pozisyon sayƒ±sƒ± kontrol√º
            if len(state.dca_positions) > 10:
                self._debug_log(strategy.id, f"üö® UYARI: √áok fazla pozisyon ({len(state.dca_positions)}), state corruption olabilir!", "WARNING")
            
            # Ortalama maliyeti g√ºncelle
            total_quantity = sum(pos.quantity for pos in state.dca_positions)
            total_cost = sum(pos.buy_price * pos.quantity for pos in state.dca_positions)
            state.avg_cost = total_cost / total_quantity if total_quantity > 0 else 0
            state.total_quantity = total_quantity
            
            self._debug_log(strategy.id, f"‚úÖ ALIM FILL: Yeni pozisyon eklendi - {trade.quantity} @ ${trade.price} (D{state.cycle_number}-{state.cycle_trade_count})")
            self._debug_log(strategy.id, f"üìä G√ºncel durum: {len(state.dca_positions)} pozisyon, Ort. maliyet: ${state.avg_cost:.4f}")
            
            self.log_strategy_action(
                strategy.id,
                "DCA_BUY",
                f"Yeni pozisyon: {trade.quantity} @ {trade.price}, Ort. maliyet: {state.avg_cost:.6f} (D{state.cycle_number}-{state.cycle_trade_count})"
            )
            
            return {
                "action": "dca_buy",
                "new_avg_cost": state.avg_cost,
                "position_count": len(state.dca_positions),
                "cycle_number": state.cycle_number,
                "cycle_trade_count": state.cycle_trade_count
            }
        
        else:  # SELL
            sell_type = trade.strategy_specific_data.get('sell_type') if hasattr(trade, 'strategy_specific_data') else 'unknown'
            
            # Satƒ±≈ü i≈ülemlerinde de sayacƒ± artƒ±r (tam satƒ±≈ü hari√ß)
            if sell_type != "full_exit":
                state.cycle_trade_count += 1
            
            self._debug_log(strategy.id, f"üìä SAT FILL: Satƒ±≈ü t√ºr√º = {sell_type}")
            
            if sell_type == "full_exit":
                # T√ºm pozisyonlarƒ± temizle - YENƒ∞ D√ñNG√ú BA≈ûLAT
                old_avg_cost = state.avg_cost
                old_positions_count = len(state.dca_positions)
                old_cycle_number = state.cycle_number
                state.dca_positions.clear()
                state.avg_cost = None
                state.total_quantity = 0.0
                
                # ƒ∞≈ülem sayacƒ±nƒ± sƒ±fƒ±rla (d√∂ng√º sayƒ±sƒ± korunur, bir sonraki alƒ±mda artƒ±rƒ±lacak)
                state.cycle_trade_count = 0
                
                # Yeni d√∂ng√º i√ßin state'i sƒ±fƒ±rla
                state.custom_data["first_buy_executed"] = False
                state.custom_data["last_ott_action"] = None
                
                self._debug_log(strategy.id, f"‚úÖ TAM SATI≈û: {old_positions_count} pozisyon temizlendi - D√∂ng√º D{old_cycle_number} tamamlandƒ±")
                self._debug_log(strategy.id, f"üí∞ Kar/Zarar: Eski ort. maliyet ${old_avg_cost:.4f} ‚Üí Satƒ±≈ü fiyatƒ± ${trade.price:.4f}")
                self._debug_log(strategy.id, f"üîÑ Pozisyonlar temizlendi - Yeni d√∂ng√º i√ßin hazƒ±r (sonraki alƒ±m D{state.cycle_number + 1} olacak)")
                
                self.log_strategy_action(
                    strategy.id,
                    "FULL_EXIT_NEW_CYCLE",
                    f"T√ºm pozisyon satƒ±ldƒ± @ {trade.price}, Eski ort. maliyet: {old_avg_cost:.6f} - D√∂ng√º D{old_cycle_number} tamamlandƒ±, sonraki d√∂ng√º D{state.cycle_number + 1} olacak"
                )
                
                return {
                    "action": "full_exit_new_cycle",
                    "exit_price": trade.price,
                    "old_avg_cost": old_avg_cost,
                    "old_cycle_number": old_cycle_number,
                    "current_cycle_number": state.cycle_number,
                    "next_cycle_number": state.cycle_number + 1,
                    "positions_cleared": True
                }
            
            elif sell_type == "partial_exit":
                # Son pozisyonu kaldƒ±r (LIFO)
                if state.dca_positions:
                    removed_position = state.dca_positions.pop()  # Son pozisyonu √ßƒ±kar
                    
                    # Ortalama maliyeti yeniden hesapla
                    if state.dca_positions:
                        total_quantity = sum(pos.quantity for pos in state.dca_positions)
                        total_cost = sum(pos.buy_price * pos.quantity for pos in state.dca_positions)
                        state.avg_cost = total_cost / total_quantity
                        state.total_quantity = total_quantity
                    else:
                        state.avg_cost = None
                        state.total_quantity = 0.0
                    
                    self._debug_log(strategy.id, f"‚úÖ KISMI SATI≈û: Son pozisyon satƒ±ldƒ± - {removed_position.quantity} @ ${removed_position.buy_price} (D{state.cycle_number}-{state.cycle_trade_count})")
                    self._debug_log(strategy.id, f"üìä Kalan pozisyonlar: {len(state.dca_positions)}, Yeni ort. maliyet: ${state.avg_cost:.4f}")
                    
                    self.log_strategy_action(
                        strategy.id,
                        "PARTIAL_EXIT",
                        f"Son pozisyon satƒ±ldƒ±: {removed_position.quantity} @ {trade.price}, Yeni ort. maliyet: {state.avg_cost}"
                    )
                
                return {
                    "action": "partial_exit",
                    "exit_price": trade.price,
                    "remaining_positions": len(state.dca_positions)
                }
            
            else:
                # Bilinmeyen satƒ±≈ü t√ºr√º - G√ºvenli varsayƒ±lan davranƒ±≈ü
                self._debug_log(strategy.id, f"‚ö†Ô∏è Bilinmeyen satƒ±≈ü t√ºr√º: {sell_type} - T√ºm pozisyonlarƒ± temizle", "WARNING")
                
                # Satƒ±lan miktarƒ± pozisyonlardan √ßƒ±kar
                remaining_quantity = trade.quantity
                removed_positions = []
                
                # LIFO sƒ±rasƒ±yla pozisyonlarƒ± √ßƒ±kar
                while remaining_quantity > 0 and state.dca_positions:
                    last_position = state.dca_positions[-1]
                    if last_position.quantity <= remaining_quantity:
                        # T√ºm pozisyonu √ßƒ±kar
                        removed_positions.append(state.dca_positions.pop())
                        remaining_quantity -= last_position.quantity
                    else:
                        # Pozisyonun bir kƒ±smƒ±nƒ± √ßƒ±kar
                        removed_quantity = remaining_quantity
                        last_position.quantity -= removed_quantity
                        remaining_quantity = 0
                        
                        # Kƒ±smi pozisyon i√ßin yeni kayƒ±t olu≈ütur
                        removed_positions.append(DCAPosition(
                            buy_price=last_position.buy_price,
                            quantity=removed_quantity,
                            timestamp=last_position.timestamp,
                            order_id=last_position.order_id
                        ))
                
                # Ortalama maliyeti yeniden hesapla
                if state.dca_positions:
                    total_quantity = sum(pos.quantity for pos in state.dca_positions)
                    total_cost = sum(pos.buy_price * pos.quantity for pos in state.dca_positions)
                    state.avg_cost = total_cost / total_quantity
                    state.total_quantity = total_quantity
                else:
                    state.avg_cost = None
                    state.total_quantity = 0.0
                    # T√ºm pozisyonlar satƒ±ldƒ±ysa yeni d√∂ng√º ba≈ülat
                    state.custom_data["first_buy_executed"] = False
                    state.custom_data["last_ott_action"] = None
                
                self._debug_log(strategy.id, f"‚úÖ G√úVENLƒ∞ SATI≈û: {len(removed_positions)} pozisyon √ßƒ±karƒ±ldƒ±")
                self._debug_log(strategy.id, f"üìä Kalan pozisyonlar: {len(state.dca_positions)}, Yeni ort. maliyet: ${state.avg_cost:.4f}")
                
                self.log_strategy_action(
                    strategy.id,
                    "SAFE_EXIT",
                    f"G√ºvenli satƒ±≈ü: {trade.quantity} @ {trade.price}, Kalan pozisyonlar: {len(state.dca_positions)}"
                )
                
                return {
                    "action": "safe_exit",
                    "exit_price": trade.price,
                    "remaining_positions": len(state.dca_positions),
                    "removed_positions": len(removed_positions)
                }
        
        return {}
    
    async def validate_strategy_config(self, strategy: Strategy) -> tuple[bool, str]:
        """DCA+OTT konfig√ºrasyon validasyonu"""
        
        base_usdt = self.get_parameter(strategy, 'base_usdt')
        if not base_usdt or base_usdt <= 0:
            return False, "DCA base_usdt parametresi gerekli ve pozitif olmalƒ±"
        
        dca_multiplier = self.get_parameter(strategy, 'dca_multiplier', 1.5)
        if dca_multiplier < 1.0 or dca_multiplier > 5.0:
            return False, "DCA multiplier 1.0-5.0 arasƒ±nda olmalƒ±"
        
        min_drop_pct = self.get_parameter(strategy, 'min_drop_pct', 2.0)
        if min_drop_pct < 0.5 or min_drop_pct > 20.0:
            return False, "Min drop percentage 0.5-20.0 arasƒ±nda olmalƒ±"
        
        # OTT parametreleri validasyonu
        if strategy.ott.period < 1 or strategy.ott.period > 200:
            return False, "OTT period 1-200 arasƒ±nda olmalƒ±"
        
        if strategy.ott.opt < 0.1 or strategy.ott.opt > 10.0:
            return False, "OTT opt 0.1-10.0 arasƒ±nda olmalƒ±"
        
        return True, "DCA+OTT konfig√ºrasyonu ge√ßerli"
